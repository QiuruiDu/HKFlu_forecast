################################################################################
# read data
################################################################################
# 进行结果的计???
library(plyr)
library(dplyr)
library(tidyverse)
library(ISOweek)
library(locpol)
library(forecast)
library(scoringutils)
library(ggplot2)
library(RColorBrewer)
library(gridExtra)
library(cowplot)
library(data.table)
setwd('/Users/hkuph/richael/RA_academic/flu/SBEM_for_HKILI/Scripts/tools')
source('MyPlot.R')
###########################################
# preparation
###########################################
origin_path = '/Users/hkuph/richael/RA_academic/flu/SBEM_for_HKILI'
setwd(origin_path)
models = c(
'Baseline',
'ARIMA_rolling',
'GARCH_rolling',
'RF_rolling',
'XGB_rolling',
'InTimePlus_v3_nontuning_rolling_v2',
'TSTPlus_v3_nontuning_rolling',
'LSTM_v3_nontuning_rolling_v2',
'GRU_v3_nontuning_rolling_v2',
'SAE_NC_R1',
'NBE',
'AWAE_NC_R1',
'AWBE_NC_R1'
)
# ,
mode = 'test8_2023'
dates_analysis <- seq(as.Date("2022-03-05"),as.Date("2024-01-21"),by="week")
if(mode == 'test4_2023'){
pred_horizon = 5
}else{
pred_horizon = 9
}
################################################################################
# prepare data
################################################################################
proj<-tibble()
for (model in models){
# model = models[1]
# model= 'Baseline'
# print(model)
path_ = paste0(origin_path, '/Results/Interval_ydiff_pred/interval_',model,'_',mode,'.csv')
if(file.exists(path_)){
proj_tmp<-read.csv(file=path_,stringsAsFactors =F)
proj_tmp$model = model
proj_tmp = proj_tmp %>%
mutate(date=as.Date(date)) %>%
mutate(point = point_avg) %>%
mutate(date_origin=date-week_ahead*7) %>%
filter(date >= min(dates_analysis)) %>%
filter(date <= max(dates_analysis)) #%>%
# filter(date_origin >= min(dates_analysis))
# the following is control the length for different week_ahead is the same
# and for 2023 prediction, I do not need this limitation, for all week_ahead, the prediction_date is the same
# std_length = length(proj_tmp$week_ahead[which(proj_tmp$week_ahead == (pred_horizon-1))])
# proj_tmp = proj_tmp %>%
#   arrange(week_ahead, date)
# proj_tmp$rank <- ave(1:nrow(proj_tmp), proj_tmp$week_ahead,FUN=seq_along)
# proj_tmp <- proj_tmp[which(proj_tmp$rank <= std_length),]
# proj_tmp = proj_tmp %>% dplyr::select(-rank)
print(paste0("--- model = ", model,', data length = ',dim(proj_tmp)[1]))
#   arrange(week_ahead, date)
# proj_tmp$rank <- ave(1:nrow(proj_tmp), proj_tmp$week_ahead,FUN=seq_along)
# proj_tmp <- proj_tmp[which(proj_tmp$rank <= 155),]
# proj_tmp = proj_tmp %>% dplyr::select(-rank)
proj<-rbind.fill(proj,proj_tmp)
}
}
proj$model<-factor(proj$model,levels=models, ordered=T)
proj.mode <- proj %>%
mutate(inclusion = 1) %>%
mutate(var="iHosp")
for(m in unique(proj.mode$model)){
print(paste0(m," --- ",dim(proj.mode[which(proj.mode$model == m),])[1],", date range = ",
min(proj.mode$date[which(proj.mode$model == m)]),", ", max(proj.mode$date[which(proj.mode$model == m)])))
}
res<-my.compute(proj.mode)
evual_result<-res %>%
filter(inclusion==1) %>%
filter(var=="iHosp") %>%
mutate(week_ahead=as.factor(week_ahead)) %>%
group_by(model,var,week_ahead) %>%
dplyr::summarize(rmse = sqrt(mean(abs_error^2,na.rm=T)) ,
mape = (mean(abs_error/abs(true),na.rm=T)),
smape = (mean(abs_error/(abs(point)+abs(true))*2,na.rm=T)),
mae = mean(abs_error, na.rm=T),
avg_wis = mean(wis, na.rm = T))%>%
ungroup() %>%
mutate(wis = avg_wis) %>%
dplyr::select(-avg_wis)
index_list = c('mae','wis','smape','mape')
re_evual_result = dcast(data.table(evual_result), model + var~week_ahead, value.var = 'rmse')
start_ = 4-1
end_ = 4+(pred_horizon-1)-1
names(re_evual_result)[start_:end_] <- paste0('rmse',0:(pred_horizon-1))
for(c in index_list){
re_c = dcast(data.table(evual_result), model + var~week_ahead, value.var = c)
names(re_c)[start_:end_] <- paste0(c,0:(pred_horizon-1))
re_evual_result = cbind(re_evual_result,re_c[,start_:end_])
}
View(re_evual_result)
model = 'AWAE_NC_R1'
# model = models[1]
# model= 'Baseline'
# print(model)
path_ = paste0(origin_path, '/Results/Interval_ydiff_pred/interval_',model,'_',mode,'.csv')
file.exists(path_)
path_
